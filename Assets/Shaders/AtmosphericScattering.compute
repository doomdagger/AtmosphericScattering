//  Copyright(c) 2016, Michal Skalsky
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1. Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//  2. Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//  3. Neither the name of the copyright holder nor the names of its contributors
//     may be used to endorse or promote products derived from this software without
//     specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
//  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT
//  SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
//  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
//  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#pragma kernel SkyboxLUT
#pragma kernel MultipleScatterLUT

RWTexture3D<float4> _SkyboxLUT;
RWTexture3D<float4> _SkyboxLUT2;
RWTexture3D<float4> _SkyboxLUTSingle;

Texture2D<half4> _GatherSumLUT2;
Texture2D<half4> _TransmittanceLUT;

SamplerState PointClampSampler;
SamplerState LinearClampSampler;

float _AtmosphereHeight;
float _PlanetRadius;
float4 _DensityScaleHeight;        
float4 _ScatteringR;
float4 _ScatteringM;
float4 _ExtinctionR;
float4 _ExtinctionM;

float4 _LightColor;

float4 _LightDir;
float4 _CameraPos;

float _MieG;

#define PI 3.14159265359

//-----------------------------------------------------------------------------------------
// ScatteringOutput
//-----------------------------------------------------------------------------------------
struct ScatteringOutput
{
	float3 rayleigh;
	float3 mie;
};

//-----------------------------------------------------------------------------------------
// RaySphereIntersection
//-----------------------------------------------------------------------------------------
float2 RaySphereIntersection(float3 rayOrigin, float3 rayDir, float3 sphereCenter, float sphereRadius)
{
    rayOrigin -= sphereCenter;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(rayOrigin, rayDir);
    float c = dot(rayOrigin, rayOrigin) - (sphereRadius * sphereRadius);
    float d = b * b - 4 * a * c;
    if (d < 0)
    {
        return -1;
    }
    else
    {
        d = sqrt(d);
        return float2(-b - d, -b + d) / (2 * a);
    }
}

//-----------------------------------------------------------------------------------------
// InvParamHeight
//-----------------------------------------------------------------------------------------
float InvParamHeight(float u_h)
{
    return u_h * u_h * _AtmosphereHeight;
}

//-----------------------------------------------------------------------------------------
// InvParamViewDirection
//-----------------------------------------------------------------------------------------
float InvParamViewDirection(float u_v, float h)
{
    float c_h = -sqrt(h * (2.0 * _PlanetRadius + h)) / (_PlanetRadius + h);
    if (u_v > 0.5)
    {
        return c_h + pow((u_v - 0.5) * 2.0, 5.0) * (1.0 - c_h);
    }
    else
    {
        return c_h - pow(u_v * 2.0, 5.0) * (1.0 + c_h);
    }
}

//-----------------------------------------------------------------------------------------
// InvParamSunDirection
//-----------------------------------------------------------------------------------------
float InvParamSunDirection(float u_s)
{
    return (tan((2.0 * u_s - 1.0 + 0.26) * 0.75)) / (tan(1.26 * 0.75));
}

//-----------------------------------------------------------------------------------------
// ParamViewDirection
//-----------------------------------------------------------------------------------------
float ParamViewDirection(float c_v, float h)
{
    float c_h = -sqrt(h * (2.0 * _PlanetRadius + h)) / (_PlanetRadius + h);
    if (c_v > c_h)
    {
        return 0.5 * pow(abs((c_v - c_h) / (1.0 - c_h)), 0.2) + 0.5;
    }
    else
    {
        return 0.5 * pow(abs((c_h - c_v) / (c_h + 1.0)), 0.2);
    }
}

//-----------------------------------------------------------------------------------------
// ParamHeight
//-----------------------------------------------------------------------------------------
float ParamHeight(float h)
{
    return pow(h / _AtmosphereHeight, 0.5);
}

void GetTransmittanceP2PA(inout float3 transmittance, float2 uv)
{
    transmittance = _TransmittanceLUT.SampleLevel(LinearClampSampler, uv, 0.0).rgb;
}

//-----------------------------------------------------------------------------------------
// ApplyPhaseFunctionElek
//-----------------------------------------------------------------------------------------
void ApplyPhaseFunctionElek(inout float3 scatterR, inout float3 scatterM, float cosAngle)
{
	// r
    float phase = (8.0 / 10.0) * ((7.0 / 5.0) + 0.5 * cosAngle);
    scatterR *= phase;

	// m
    float g = _MieG;
    float g2 = g * g;
    phase = ((3.0 * (1.0 - g2)) / (2.0 * (2.0 + g2))) * ((1 + cosAngle * cosAngle) / (pow((1 + g2 - 2 * g * cosAngle), 3.0 / 2.0)));
    scatterM *= phase;
}

//-----------------------------------------------------------------------------------------
// PrepareAllParametersForScattering
//-----------------------------------------------------------------------------------------
void PrepareAllParametersForScattering(float3 coords, out float3 rayStart, out float3 rayDir, out float rayLength, out float3 planetCenter, out float3 lightDir, out float height)
{
    height = InvParamHeight(coords.x);
    float viewZenithAngle = InvParamViewDirection(coords.y, height);
    float sunZenithAngle = InvParamSunDirection(coords.z);

    planetCenter = float3(0, -_PlanetRadius, 0);
    rayStart = float3(0, height, 0);

    rayDir = float3(sqrt(saturate(1 - viewZenithAngle * viewZenithAngle)), viewZenithAngle, 0);
    lightDir = -float3(sqrt(saturate(1 - sunZenithAngle * sunZenithAngle)), sunZenithAngle, 0);

    float2 intersection = RaySphereIntersection(rayStart, rayDir, planetCenter, _PlanetRadius + _AtmosphereHeight);
    rayLength = intersection.y;

    intersection = RaySphereIntersection(rayStart, rayDir, planetCenter, _PlanetRadius);
    if (intersection.x > 0)
        rayLength = min(rayLength, intersection.x);
}

//-----------------------------------------------------------------------------------------
// IntegrateInscattering
//-----------------------------------------------------------------------------------------
ScatteringOutput IntegrateInscattering(float3 rayStart, float3 rayDir, float rayLength, float3 planetCenter, float3 lightDir, float height)
{
	float sampleCount = 64;
    float stepSize = length(rayDir * rayLength) / sampleCount;

    float2 previousDensity, currentDensity, totalDensity;
    float3 previousScatterR, currentScatterR, totalScatterR;
    float3 previousScatterM, currentScatterM, totalScatterM;

    float2 transUV;
    transUV.x = ParamViewDirection(-lightDir.y, height);
    transUV.y = ParamHeight(height);

    float3 transmittance;
    previousDensity = exp(-(height.xx / _DensityScaleHeight.xy));
    GetTransmittanceP2PA(transmittance, transUV);

    previousScatterR = previousDensity.x * transmittance;
    previousScatterM = previousDensity.y * transmittance;

	// P - current integration point
	// C - camera position
	// A - top of the atmosphere
	[loop]
	for (int step = 1; step <= sampleCount; step += 1)
	{
		float3 p = rayStart + step * stepSize * rayDir;

        height = length(p - planetCenter) - _PlanetRadius;
        transUV.x = ParamViewDirection(-lightDir.y, height);
        transUV.y = ParamHeight(height);

        currentDensity = exp(-(height.xx / _DensityScaleHeight.xy));
        totalDensity += (currentDensity + previousDensity) / 2.0 * stepSize;

        GetTransmittanceP2PA(transmittance, transUV);
        transmittance *= exp(-(totalDensity.x * _ExtinctionR.xyz + totalDensity.y * _ExtinctionM.xyz));

        currentScatterR = transmittance * currentDensity.x;
        currentScatterM = transmittance * currentDensity.y;

        totalScatterR += (previousScatterR + currentScatterR) / 2.0 * stepSize;
        totalScatterM += (previousScatterM + currentScatterM) / 2.0 * stepSize;

        previousDensity = currentDensity;
        previousScatterR = currentScatterR;
        previousScatterM = currentScatterM;
	}

	ScatteringOutput output;

    float3 coef = 1.0 / (4.0 * PI) * _LightColor.rgb;

    totalScatterR *= _ScatteringR.xyz * coef;
    totalScatterM *= _ScatteringM.xyz * coef;

    // Attention: should apply Phase Function after Mie approximation!
    // ApplyPhaseFunctionElek(totalScatterR, totalScatterM, dot(-lightDir, rayDir));

	output.rayleigh = max(totalScatterR, 0);
	output.mie = max(totalScatterM, 0);

	return output;
}

//-----------------------------------------------------------------------------------------
// SkyboxLUT
//-----------------------------------------------------------------------------------------
[numthreads(1,1,1)]
void SkyboxLUT(uint3 id : SV_DispatchThreadID)
{
	float w, h, d;
	_SkyboxLUT.GetDimensions(w, h, d);

	// linear parameters
	float3 coords = float3(id.x / (w - 1), id.y / (h - 1), id.z / (d - 1));

    float3 rayStart, rayDir, planetCenter, lightDir;
    float rayLength, height;

    PrepareAllParametersForScattering(coords, rayStart, rayDir, rayLength, planetCenter, lightDir, height);

	ScatteringOutput scattering = IntegrateInscattering(rayStart, rayDir, rayLength, planetCenter, lightDir, height);
	
	_SkyboxLUT[id.xyz] = float4(scattering.rayleigh.xyz, scattering.mie.x);
	_SkyboxLUTSingle[id.xyz] = float4(scattering.rayleigh.xyz, scattering.mie.x);
}


//-----------------------------------------------------------------------------------------
// GetDirectionFromCos
//-----------------------------------------------------------------------------------------
float3 GetDirectionFromCos(float cos_value)
{
    return float3(sqrt(saturate(1 - cos_value * cos_value)), cos_value, 0);
}

//-----------------------------------------------------------------------------------------
// ApproximateMieFromRayleigh
//-----------------------------------------------------------------------------------------
void ApproximateMieFromRayleigh(in float4 scatterR, out float3 scatterM)
{
    scatterM.xyz = scatterR.xyz * ((scatterR.w) / (scatterR.x)) * (_ScatteringR.x / _ScatteringM.x) * (_ScatteringM.xyz / _ScatteringR.xyz);
}

//-----------------------------------------------------------------------------------------
// GatherSum
//-----------------------------------------------------------------------------------------
void GatherSum(out float3 scatterR, out float3 scatterM, float2 coords)
{
	float4 gathered = _GatherSumLUT2.SampleLevel(LinearClampSampler, coords, 0.0);
	scatterR = gathered.xyz;
	ApproximateMieFromRayleigh(gathered, scatterM);
}

//-----------------------------------------------------------------------------------------
// IntegrateMultiScattering
//-----------------------------------------------------------------------------------------
ScatteringOutput IntegrateMultiScattering(float3 rayStart, float3 rayDir, float rayLength, float3 planetCenter, float3 lightDir, float height, float3 coords)
{
    float sampleCount = 64;
    float stepSize = length(rayDir * rayLength) / sampleCount;

    float2 previousDensity, currentDensity, totalDensity;
    float3 previousScatterR, currentScatterR, totalScatterR;
    float3 previousScatterM, currentScatterM, totalScatterM;
    float3 gatheredScatterR, gatheredScatterM;

    float3 transmittance;
    previousDensity = exp(-(height.xx / _DensityScaleHeight.xy));

    GatherSum(gatheredScatterR, gatheredScatterM, coords.xz);

    previousScatterR = previousDensity.x * gatheredScatterR;
    previousScatterM = previousDensity.y * gatheredScatterM;

	// P - current integration point
	// C - camera position
	// A - top of the atmosphere
	[loop]
    for (int step = 1; step <= sampleCount; step += 1)
    {
        float3 p = rayStart + step * stepSize * rayDir;

        height = length(p - planetCenter) - _PlanetRadius;

        currentDensity = exp(-(height.xx / _DensityScaleHeight.xy));
        totalDensity += (currentDensity + previousDensity) / 2.0 * stepSize;

        transmittance = exp(-(totalDensity.x * _ExtinctionR.xyz + totalDensity.y * _ExtinctionM.xyz));

		GatherSum(gatheredScatterR, gatheredScatterM, coords.xz);

        currentScatterR = transmittance * currentDensity.x * gatheredScatterR;
        currentScatterM = transmittance * currentDensity.y * gatheredScatterM;

        totalScatterR += (previousScatterR + currentScatterR) / 2.0 * stepSize;
        totalScatterM += (previousScatterM + currentScatterM) / 2.0 * stepSize;

        previousDensity = currentDensity;
        previousScatterR = currentScatterR;
        previousScatterM = currentScatterM;
    }

    ScatteringOutput output;

    float3 coef = 1.0 / (4.0 * PI);

    totalScatterR *= _ScatteringR.xyz * coef;
    totalScatterM *= _ScatteringM.xyz * coef;

    // Attention: should apply Phase Function after Mie approximation!

    output.rayleigh = max(totalScatterR, 0.0);
    output.mie = max(totalScatterM, 0.0);

    return output;
}

//-----------------------------------------------------------------------------------------
// MultipleOrdering Scattering
//-----------------------------------------------------------------------------------------
[numthreads(1, 1, 1)]
void MultipleScatterLUT(uint3 id : SV_DispatchThreadID)
{
    float w, h, d;
    _SkyboxLUT2.GetDimensions(w, h, d);

	// linear parameters
    float3 coords = float3(id.x / (w - 1), id.y / (h - 1), id.z / (d - 1));

    float3 rayStart, rayDir, planetCenter, lightDir;
    float rayLength, height;

    PrepareAllParametersForScattering(coords, rayStart, rayDir, rayLength, planetCenter, lightDir, height);

    ScatteringOutput scattering = IntegrateMultiScattering(rayStart, rayDir, rayLength, planetCenter, lightDir, height, coords);
	
    _SkyboxLUT2[id.xyz] = float4(scattering.rayleigh.xyz, scattering.mie.x);
	_SkyboxLUT[id.xyz] += float4(scattering.rayleigh.xyz, scattering.mie.x);
}